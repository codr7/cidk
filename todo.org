fun (fib (n Int) Int
  if n.< 2 n fib(n.- 1).+ fib(n.- 2)
)

fun (fib ((n a b) Int) Int
  if n.= 0 a if n.= 1 b fib(n.- 1 b a.+ b)
)

* add Fix type
** add [Fix Fix] fun overloads
** add [Fix Int] fun overloads
* --
* mark regs/stack in cx.mark()
* add custom read_id in calcl
** break on isdigit, () and =
* rename calcl op to calc
** update tests
* add calcl assignment support
** check for '=' after read_id
** set to next value
*** use group for more
* add default args
** x 42 instead of x Int
** clone on let
** add nargs to Call op
*** update test/bench/readme
** use for a/b in fib_iter
*** bench
* add nargs to Dispatch op
* add EnvItem
** Env *env; const Sym *id; Val val;
** add support in Env::let
*** replace val if env != this
** remove Val.id
* add type unions
** parse Type? as Type|_
** remove any_type
** don't derive Nil from a_type
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
* add repl break loop
** add restarts
** gfu
* add anon fun support
** push on stack from Defun if nil id
* add Fun.rets (Rets)
** match stack if cx.debug
* add recall op type check/reuse args
** default F T
** call in new frame if reuse=F
