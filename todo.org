fun (fib (n Int) Int
  if n.< 2 n fib(n.- 1).+ fib(n.- 2)
)

fun (fib ((n a b) Int) Int
  if n.= 0 a if n.= 1 b fib(n.- 1 b a.+ b)
)

* finish op args
** convert cp/drop/poke/set ops
** remove Op.data/as
** commit op args
* remove read_id env lookup
** change ops to check types in compile
*** store vals
** eval val in defconst compile
** block let const override
*** check in compile
** block set of const
* --
* calcl
** change read to treat every second val as Op/Val regardless of type
*** read num if digit else id
*** remove ReadCx
**** complete sequence in read_next
*** use read_val
*** use call-bin
* add read_expr
** copy cidk::read_list and emit expr
* --
** add calc op
*** calc 35 + 7;
** add link op
*** dl
** add tests using link/calc
* ---
* add Fix type
** store value
** use number of decimals to determine scale
* mark regs/stack in cx.mark()
* add repl break loop
** add restarts
** gfu
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
* add Quote type
** like ConstType
** add '-reader
* add Fun.rets (Rets)
** match against stack suffix if cx.debug
* add anon fun support
** push on stack from Defun if nil id
* add Fun arg type checking if cx.debug
** skip type A
* add Splice support
** splice list items automagically
* add return
** add eval state
** handle in Call.eval
