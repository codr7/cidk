* add Env.add_const_expr construct expr from op args & bind const
** remove macro
* switch Fun imp to pass Cx, Pos, Fun instead of Call
* add default add/sub/mul/div/gt/lt FunImp:s to ValType
** use instead of env lookup if same type
* --
* add @ char reader
** read utf8
* add Splat op
** vararg like Push
** call splat on eval
* add len op
** forward to type env
** add Str/List/Env.len funs
* add ReadState stack & Env args to load
** pass between loaded files in main
** forward args in include-op

* add fib_iter bench
** add set op
** add expr support like poke
* remove Env/Def.cx
** pass args instead
* simplify read_eop()
** use skip_ws/get/unget instead
* remove typed Val constructor Pos arg
* add mod op like mul
** add math/int_mod
* add stack type inference
** add Fun.rets (Rets)
** process stack in OpType inits
** add cx, env, stack to OpType inits / op constructor
** add Undef type
*** store actual as_type
** add unify(Stack &x, Stack &y)
** use to lookup fn at read-time in BinOp
* push Fun on stack from Defun if missing id
* add Fun arg type checking
** skip args with type A
* add Quote type
** struct with embedded Val
** add '-reader
* add Splice support
** splice list items automagically

fun fib(n Int)(Int) {
  if n < 2 n {fib(n - 1) + fib(n - 2)}
}

fun fib((n a b) Int)(Int) {
  if n = 0 a if n = 1 b fib(n - 1, b, a + b)
}


fun fib(n Int)(Int) {
  if n.<(2) n fib(n.-(1)).+(fib(n.-(2)))
}

fun fib((n a b) Int)(Int) {
  if n.=(0) a if n.=(1) b fib(n.-(1) b a.+(b))
}


fun(fib (n Int) (Int)
  if n.<(2) n fib(n.-(1)).+(fib(n.-(2)))
)

fun(fib ((n a b) Int) (Int)
  if(n.=(0) a if(n.=(1) b fib(n.-(1) b a.+(b))))
)
