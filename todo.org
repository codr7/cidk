fun (fib (n Int) Int
  if n.< 2 n fib(n.- 1).+ fib(n.- 2)
)

fun (fib ((n a b) Int) Int
  if n.= 0 a if n.= 1 b fib(n.- 1 b a.+ b)
)

* reuse stack.back in is-op?
* remove Op/Val.get_ids() fns
* remove Env.use()
* remove IdSet
** test.al
* clone fun in defun eval
** copy ops
* simplify Env
** replace EnvItem with Val
* --
* add cx.stack
** remove stack args
** add stackp like regs
* copy regs into env arg in env op
** add failing test
* mark regs in cx.mark()
* replace cx.ops with cx.on_mark
** function<void ()>
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
*** let / del
**** add Env.del
*** update val in place
* --
* add Splat op
** vararg like Push
** call splat on eval
* add len op
** forward to type env
** add Str/List/Env.len funs
* add Fun.rets (Rets)
** match against stack suffix if cx.debug
* add stack type inference
** process stack in compile
** add Undef type
*** store actual as_type
** add unify(Stack &x, Stack &y)
** use to pick fn at read-time in BinOp
* push Fun on stack from Defun if missing id
* add Fun arg type checking
** skip type A
* add Quote type
** like ConstType
** add '-reader
* add Splice support
** splice list items automagically
* add mod op like mul
** add math/int_mod
* add isa x? y? op
* add return
** add eval state
** handle in Call.eval
* block setting of const vals
** check for const_type
