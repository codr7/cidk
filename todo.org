* only create Call for body-funs
** switch Fun imp to const Pos &, Fun &, ...
** extract Fun.call from Call.eval()
* add type inference
** process stack/env in OpType inits
** add cx, env, stack to OpType inits / op constructor
** add Undef type
*** store actual as_type
** add unify(Stack &x, Stack &y)
** add Env.unify(const Env &y)
** use to lookup add-fn at read-time
* switch < to op
** copy add-op to lt
*** support vararg like is-op
** drop Call.forward/fun overload
** drop cx.lt_sym
** bench
*** pass literal arg instead of push
* fix add-op vararg
** get 1+ x from stack
* --
* add check op
** check (foo bar) {push foo bar 42; add; is;};
** first arg is optional context that's evaluated and printed on fail
* add repl
** launch if no args
** only eval if last char is ;
** clear stack on empty input
* add fib_iter bench
** add env.update(is, function<void>(Val &))
*** use setter (set-X in current env) if available
* convert dec to op
** support env update for sym
* add 'include' op
** vararg like 'call'
** load ops on read and store in data
** eval on eval
* add Quote type
** struct with embedded Val
** add '-reader
** add Splice support
*** splice list items automagially
* add Splat op
* add lambda support
** &{...}
** anonymous Fun
* add Char type
** char32_t
* add Str type
** read as utf-8
*** https://stackoverflow.com/questions/16208079/how-to-work-with-utf-8-in-c-conversion-from-other-encodings-to-utf-8
** splat chars
* add >
** default using lt
* add Fun.rets (Rets)

defun fib(_ Int)(Int) {
  if {dup; push 2; lt;} _ {
    dec; dup;
    call fib;
    swap; dec; 
    call fib;
    add;
  };
};
