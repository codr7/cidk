* fix repl/load env
** cidk & calcl
** test load
*** set var in test1.al and use in test2.al
** use opts/regs to fill env on successful eval
** add set(reg, val) fn
*** set val.id
*** use instead of direct access
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
** add to readme
* add list bench
** add seq lib with push/pop/reserve funs
* remove eval env-arg
** remove Fun.env + constructor arg
** bench
* add default args
** x 42 instead of x Int
** clone on let
** add nargs to Call op
*** update test/bench/readme
** use for a/b in fib_iter
*** bench
* add nargs to Dispatch op
* compile Dispatch to Call if list.size() == 1
* peel off Do at compile time if no let/defun/defconst
* add sum types
** parse Type? as Type or Nil_
** remove any_type
** don't derive Nil from a_type
* add repl break loop
** add restarts
** gfu
* add anon fun support
** push on stack from Defun if nil id
* add Fun.rets (Rets)
** match stack if cx.debug
* add recall op type check/reuse args
** default F T
** call in new frame if reuse=F
