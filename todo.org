* switch FunImp to passing Cx, Pos, Fun instead of Call
* add add/sub/mul/div/gt/lt fimps to ValType
** use instead of env lookup if same type
*** change BinOp to take id and fimp
* --
* rename ReadState to Opts
** add cx.compile(Ops &in, Opts &opts)
*** add OpType.compile(Cx &cx, Op &op, Env &env, Stack &stack, Opts &opts, Ops &out)
*** call to compile Fun body
** add Opts, Stack & Env args to Cx.load
*** pass to compile
*** pass between loaded files in main
*** forward args in include-op
* skip stack arg to op readers
* remove Env/Def.cx
** pass args instead
* add @ char reader
** read utf8
* add Splat op
** vararg like Push
** call splat on eval
* add len op
** forward to type env
** add Str/List/Env.len funs
* add fib_iter bench
** add set op
** add expr support like poke
* simplify read_eop()
** use skip_ws/get/unget instead
* remove typed Val constructor Pos arg
* add mod op like mul
** add math/int_mod
* add stack type inference
** add Fun.rets (Rets)
** process stack in OpType inits
** add cx, env, stack to OpType inits / op constructor
** add Undef type
*** store actual as_type
** add unify(Stack &x, Stack &y)
** use to lookup fn at read-time in BinOp
* push Fun on stack from Defun if missing id
* add Fun arg type checking
** skip args with type A
* add Quote type
** struct with embedded Val
** add '-reader
* add Splice support
** splice list items automagically

fun (fib (n Int) Int
  if n.< 2 n fib(n.- 1).+ fib(n.- 2)
)

fun (fib ((n a b) Int) Int
  if n.= 0 a if n.= 1 b fib(n.- 1 b a.+ b)
)

