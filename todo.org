* switch Pos.src to optional<Path>
** change error dump to skip src if missing
** change cidk/calcl/dasl repls to pass {}
** update readme
* add support for fun calls in dasl like calcl
* --
* add EnvItem
** Val & bool is_const
** drop const type
* --
* add dump(ops, out) fn
** add Op.dump(depth, out)
** add ops::dump_arg(Val, out)
*** dump expressions at depth+1 with newlines
** add OpType.dump(out)
* add calcl :compile command
** dump generated ops
* ---
* add deflib op
** pass lib.env down in compile/eval
* add support for recursive ids
** foo.bar.baz
** add sym.parts vector
*** default this
** throw error if target is not Lib
* add use op
* --
* remove cx arg from Env constructors/add_const/set
* fix compile time detection of unknown args
** dispatch foo;
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
** add to readme
* add list bench
** add list lib with push/pop/reserve funs
* add enum types
** use instead of bool op flags
** add pair support
*** a:b
*** add Pair < Ref
* add default args
** x 42:Int / x 42 / x Int
** add ArgList.min_nargs
*** calculate during parse
** clone on let
** add nargs to Call op like dispatch
*** update test/bench/readme
** use for a/b in fib_iter
*** bench
* compile Dispatch to Call if list.size() == 1
* add sum types
** parse Type? as Type or Nil_
** remove any_type
** don't derive Nil from a_type
* add repl break loop
** add restarts
** gfu
* add anon fun support
** push on stack from Defun if nil id
* add Fun.rets (Rets)
** match stack if cx.debug
* add recall op type check/reuse args
** default F T
** call in new frame if reuse=F
