abc.ds

lib abc {
  fun %(x Num y Num)(Num) {x - ((x / y) * y)}

  var foo = 9
  foo += 1
}

use abc(%)
dump(abc.foo % 4)

* cleanup dasl
** script op
*** use read_expr
** compile
** git import
* --
* add deflib op
** pass lib.env down in compile/eval
* add support for recursive ids
** foo.bar.baz
** add sym.parts vector
*** default this
** throw error if target is not Lib
* add use op
* --
* remove cx arg from Env constructors/add_const/set
* fix compile time detection of unknown args
** dispatch foo;
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
** add to readme
* add list bench
** add list lib with push/pop/reserve funs
* add enum types
** use instead of bool op flags
* add default args
** x 42 instead of x Int
** clone on let
** add nargs to Call op like dispatch
*** update test/bench/readme
** use for a/b in fib_iter
*** bench
* compile Dispatch to Call if list.size() == 1
* peel off Do at compile time if no let/defun/defconst
* add sum types
** parse Type? as Type or Nil_
** remove any_type
** don't derive Nil from a_type
* add repl break loop
** add restarts
** gfu
* add -foo support
** add Neg op
** emit after val push if val.flags &= CIDK_VAL_NEG
* add anon fun support
** push on stack from Defun if nil id
* add Fun.rets (Rets)
** match stack if cx.debug
* add recall op type check/reuse args
** default F T
** call in new frame if reuse=F
