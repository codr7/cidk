scriptl
abc.sl

lib abc {
  fun %(x Num y Num)(Num) {x - ((x / y) * y)}

  var foo = 9
  foo += 1
}

use abc(%)
dump(abc.foo % 4)

* add libs
** add deflib op
*** add cx.lib
*** set/restore in deflib
*** switch cx.env to Env*
**** override/restore in deflib
* add support for recursive ids
** foo.bar.baz
** add sym.parts vector
*** default this
** throw error if target is not Lib
* add use op
** env.use(const Pos &pos, const Env &src, {ids...})
* --
* remove cx arg from Env constructors
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
** add to readme
* add list bench
** add list lib with push/pop/reserve funs
* add default args
** x 42 instead of x Int
** clone on let
** add nargs to Call op
*** update test/bench/readme
** use for a/b in fib_iter
*** bench
* add nargs to Dispatch op
* compile Dispatch to Call if list.size() == 1
* peel off Do at compile time if no let/defun/defconst
* add sum types
** parse Type? as Type or Nil_
** remove any_type
** don't derive Nil from a_type
* add repl break loop
** add restarts
** gfu
* add anon fun support
** push on stack from Defun if nil id
* add Fun.rets (Rets)
** match stack if cx.debug
* add recall op type check/reuse args
** default F T
** call in new frame if reuse=F
