* add fib_tail
** add Fun.arg_list
*** add ArgList.parse
*** parse pairs of id/type
**** use _ to skip id / type
**** update existing funs
*** init id from id_name if null
** switch fun body to Expr
*** validate in Fun op
*** emit code to bind args to fun body in constructor
** commit fib_tail
* --
* split pop() into Val pop(s) and optional<Val> try_pop(s)
* grep 'env_pool.get' and sweep manually like Call.eval()

* --
* add Reader type
** move pos, src & state to fields
** grep istream & replace with Reader
** inc/dec state.env_depth around do_env
** set env_escape in env op unless env_depth > 0
** copy reader.state to Fun.body_opts
* add mark/sweep ops
** mark call stack funs in cx.mark()
** call mark/sweep in fib_rec bench body & compare

* switch Env.items to sorted deque or vector
* --
* add stack accessor like env
** op + macro
** push as list & move items
* add repl
** launch if no args
** only eval if last char is ;
** clear stack on empty input
* add env.update(is, function<void>(Val &))
** use setter (set-X in current env) if available
* add 'include' op
** vararg like 'call'
** load ops on read and store in data
** eval on eval
* add Quote type
** struct with embedded Val
** add '-reader
* add Splat op
* add lambda support
** &{...}
** anonymous Fun
* add Char type
** char32_t
* add Str type
** read as utf-8
*** https://stackoverflow.com/questions/16208079/how-to-work-with-utf-8-in-c-conversion-from-other-encodings-to-utf-8
** splat chars
* add >
** default using lt
* add optional dup op offs arg
* add optional swap op offs arg
* add drop op nvals arg
* add Fun.rets (Rets)

(fun f (n (a 0) (b 1))
  (if n 
    (if (= n 1)
      b
      (recall (- n 1) b (+ a b)))
    a))
