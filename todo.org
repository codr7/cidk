* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
** add to readme
* add list bench
** add list lib with push/pop/reserve funs
* add libs
** add Lib < Def
** embed Env env
** add Env.add_lib(id)
** add deflib op
** add support for recursive ids
*** foo.bar.baz
*** throw error if not Lib
* add default args
** x 42 instead of x Int
** clone on let
** add nargs to Call op
*** update test/bench/readme
** use for a/b in fib_iter
*** bench
* add nargs to Dispatch op
* compile Dispatch to Call if list.size() == 1
* peel off Do at compile time if no let/defun/defconst
* add sum types
** parse Type? as Type or Nil_
** remove any_type
** don't derive Nil from a_type
* add repl break loop
** add restarts
** gfu
* add anon fun support
** push on stack from Defun if nil id
* add Fun.rets (Rets)
** match stack if cx.debug
* add recall op type check/reuse args
** default F T
** call in new frame if reuse=F
