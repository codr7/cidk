fun (fib (n Int) Int
  if n.< 2 n fib(n.- 1).+ fib(n.- 2)
)

fun (fib ((n a b) Int) Int
  if n.= 0 a if n.= 1 b fib(n.- 1 b a.+ b)
)

* rename call-bin to dispatch
** dispatch 2 + -[Int Int];
** collect args in List
*** expand/typecheck/sort by reverse weight on compile
** use bsearch to skip weight > stack on eval
*** call first match
** update test/readme
* throw error on missing id
** test.al
* --
* add read_parens
** copy cidk::read_list and emit expr
* add calc op
** calc 35 + 7;
* add link op
** dl
** add calc tests using link
* ---
* switch Env::Items to map
** bench
* add Fix type
** store value
** use number of decimals as scale
* mark regs/stack in cx.mark()
* add repl break loop
** add restarts
** gfu
* finish for op
** add ValType.iter(const Val &src, function<void (const Val &)>)
*** call with src in default imp
*** update for op to use iter
** bind var if not _
* add anon fun support
** push on stack from Defun if nil id
* add Fun.rets (Rets)
** match against stack suffix if cx.debug
